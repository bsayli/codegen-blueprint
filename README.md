# Codegen Blueprint â€” Architecture-First Project Generator

[![Build](https://github.com/blueprint-platform/codegen-blueprint/actions/workflows/build.yml/badge.svg)](https://github.com/blueprint-platform/codegen-blueprint/actions/workflows/build.yml)
[![Release](https://img.shields.io/github/v/release/blueprint-platform/codegen-blueprint?logo=github\&label=release)](https://github.com/blueprint-platform/codegen-blueprint/releases/latest)
[![CodeQL](https://github.com/blueprint-platform/codegen-blueprint/actions/workflows/codeql.yml/badge.svg)](https://github.com/blueprint-platform/codegen-blueprint/actions/workflows/codeql.yml)
[![codecov](https://codecov.io/gh/blueprint-platform/codegen-blueprint/branch/main/graph/badge.svg)](https://codecov.io/gh/blueprint-platform/codegen-blueprint/tree/main)
[![Java](https://img.shields.io/badge/Java-21-red?logo=openjdk)](https://openjdk.org/projects/jdk/21/)
[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.5%2B-green?logo=springboot)](https://spring.io/projects/spring-boot)
[![Maven](https://img.shields.io/badge/Maven-3.9-blue?logo=apachemaven)](https://maven.apache.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

<p align="center">
  <img src="docs/images/cover/cover.png" alt="Executable Architecture â€” From Day Zero" width="700" />
</p>

> **Codegen Blueprint** is for teams who care less about *how fast a project starts*
> and more about *how well its architecture survives over time*.

---

## If youâ€™ve everâ€¦

* Your codebase started clean â€” then **architecture drifted silently** once things were â€œup and runningâ€.
* A new developer (or a rushed change) put code in the **wrong layer** â€” and the only â€œruleâ€ was tribal knowledge.
* A review turned into **â€œis this the right boundary?â€** debates â€” because nothing was **executable**.

Codegen Blueprint exists for that exact moment.

---

## Try it in 5 minutes

### Prerequisites

* Java 21
* Maven 3.9+
* macOS or Linux

> Goal: see **GREEN â†’ RED â†’ GREEN** purely via **build-time architecture guardrails**.
>
> No application startup. No runtime checks.
> Just deterministic feedback during `mvn verify`.

---

### 1) Build the generator JAR

```bash
mvn -q clean package
```

---

### 2) Run the executable architecture proof

```bash
cd docs/demo
./proof-runner.sh
```

---

### What you should see

* âœ… A project is generated with **strict** guardrails
* âœ… `mvn verify` passes (baseline)
* âŒ An intentional architectural boundary violation is introduced
* âŒ `mvn verify` fails **deterministically** with a generated ArchUnit rule
* âœ… The violation is reverted and the build returns to green

ğŸ‘‰ Full walkthrough (screenshots + exact failures):

[Executable Architecture Proof](docs/demo/executable-architecture-proof.md)

---

> If youâ€™re looking for a fast scaffold, use Spring Initializr.
> If you want architecture that stays **observable and executable** over time, start here.

---


### ğŸ¤” Should I clone this repository?

Clone this project if youâ€™ve ever seen a codebase start clean and slowly drift into chaos â€”
where architectural rules exist only in slides, not in code.

**Codegen Blueprint is not a faster way to scaffold a project.**
It is a deliberate way to turn architectural intent into **executable, testable guardrails**
that provide **fast, build-time feedback** from day zero.

It doesnâ€™t just generate a project â€”
it generates a project whose architectural boundaries remain **continuously verifiable on every build**.

If long-term maintainability, domain purity, and **early visibility when boundary drift begins** matter to you,
this repository is worth your time.

---

### ğŸ›¡ 1.0.0 Non-Negotiable Promise

**Every project generated by Codegen Blueprint 1.0.0 can include executable architectural guardrails â€” when enabled.**
Not documentation, not conventions â€” but **generated, executable rules** that make architectural drift visible immediately.

These guardrails provide **early, unambiguous build-time feedback**,
turning architectural intent into a **living contract** rather than a set of guidelines.

When boundaries are crossed, the build does not silently succeed â€”
it **signals the drift clearly**, while context is still fresh and easy to correct.

This is not about punishment or restriction.
It is about **protecting architectural intent as the system evolves**.

> **Contract clarity**
>
> The authoritative GA guarantee surface is defined only by the
> **Executable Architecture Contract â€” 1.0.0 GA**.

## Release & Compatibility Discipline

Codegen Blueprint follows an explicit **release discipline** where versions represent
**architectural and compatibility contracts**, not feature counts.
Starting from **1.0.0 GA**, guarantees around generation determinism, structure,
and executable architecture guardrails are intentional and protected.

Breaking changes are introduced **only in major versions** and are never silent.

For details, see:

ğŸ‘‰ [Release Discipline](docs/policies/release-discipline.md)

### What We Explicitly Do NOT Guarantee

Codegen Blueprint is intentionally **constrained by design**.
Some things are not supported â€” not by accident, but to protect architectural integrity.

Before adopting the project, please review what is **explicitly out of scope**:

ğŸ‘‰ [What We Do NOT Guarantee](docs/policies/what-we-do-not-guarantee.md)

### ğŸ§¾ Project History (Short)

Codegen Blueprint started as an early experiment in Spring Boot project bootstrapping (`codegen-springboot-initializr`).
As the project evolved, the focus shifted from â€œscaffoldingâ€ to **Executable Architecture** â€” guardrails that can fail the build.
The current `main` branch reflects this pivot and the architecture-first direction.
Earlier `0.x` tags are kept for historical context and experimentation, but they do **not** define the GA guarantees.
**The compatibility and guarantee contract begins with 1.0.0 GA.**

## ğŸ§­ Architecture as a Product

> In Blueprint, **Executable Architecture** is the outcome,
> **guardrails** are the mechanism that enforce it at build time,
> and **contract evolution discipline (governance)** is how those guardrails change safely over time.
>
> **Contract evolution discipline** means evolving the guardrails contract
> (today implemented as generated ArchUnit rules)
> without silently changing what the build guarantees.
>
> **Guardrails** here means **explicit, non-negotiable architectural constraints**
> that are **evaluated automatically during `mvn verify`**
> (not guidelines, not documentation).

Most teams donâ€™t fail because they chose the wrong framework.
They fail because **architecture slowly drifts once the project is â€œup and running.â€**

What starts as a clean design turns into:

* shortcuts under delivery pressure
* blurred boundaries between layers
* domain logic leaking into frameworks
* â€œweâ€™ll fix it laterâ€ decisions that never get fixed

Traditional project generators help you **start fast** â€”
but they disappear the moment the first commit is made.

**Codegen Blueprint exists to address what happens *after* generation.**

It treats architecture as a **first-class, executable product** that:

* **Makes architectural boundaries visible** â€” layered and/or Hexagonal (opt-in)
* **Surfaces architectural drift early**, before it becomes structural damage
* **Keeps the domain insulated from frameworks by construction**
* **Aligns early decisions across teams** â€” automatically and consistently

> **Executable Architecture â€” Delivered from day zero. Sustained over time.**

<p align="center">
  <img src="docs/images/architecture/value-proposition.png" width="780" alt="Value proposition of Codegen Blueprint showing stakeholders, architecture engine capabilities, and long-term alignment outcomes"/>
</p>

---

ğŸ”— Part of the **Blueprint Platform** â†’ [blueprint-platform](https://github.com/blueprint-platform)

ğŸ¤ [Contributing](#-contributing)

---

### ğŸ¯ Who is this for?

| Role                 | Problem Solved                                              |
| -------------------- | ----------------------------------------------------------- |
| Platform Engineering | Org-wide standards made **explicit and verifiable**         |
| Lead Architects      | Guardrails contracts made **observable**                    |
| Developers           | No boilerplate â€” productivity from day zero                 |
| New Team Members     | Architecture learning curve reduced by executable structure |

---

### ğŸ¥‡ What makes it different?

> **Initializr-like convenience** â†’ **Architecture-first evolution**

| Capability Focus         | Spring Initializr / JHipster | Codegen Blueprint |
| ------------------------ | ---------------------------- | ----------------- |
| Folder scaffolding       | âœ”                            | âœ”                 |
| Architecture guardrails  | âš ï¸                           | **âœ”**             |
| Frameworkâ€‘free domain    | âŒ                            | **âœ”**             |
| Profileâ€‘driven evolution | âš ï¸                           | **âœ”**             |
| Antiâ€‘drift roadmap       | âŒ                            | **âœ”**             |

---

### ğŸ§© Generate vs Deliver Capabilities (Cross-Cutting Concerns)

Most generators **generate code** for cross-cutting concerns.
That approach does not scale.

**Codegen Blueprint makes a deliberate distinction:**

| Approach                | What happens                                                 | Long-term effect                              |
| ----------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| Generate code           | Copies security, logging, error handling into each service   | âŒ Drift, copy-paste, painful upgrades         |
| Deliver as capabilities | Centralized, versioned, opt-in behavior via shared libraries | **âœ” Consistency, easier upgrades, alignment** |

> **Not everything should be generated.**
> Cross-cutting concerns should be **delivered as capabilities**, not duplicated as code.

With Blueprint Platform:

* Architecture is generated once
* Runtime behavior is **standardized via shared libraries / BOMs**
* Capabilities are **centrally versioned and opt-in**
* Upgrades happen in **one place**, not across 50 microservices

This is why Blueprint is not a template collection.

> **It is architecture as an executable product â€”
> where behavior is shared, aligned, and evolves safely over time.**

---

> ğŸ§© Same simplicity â€” **stronger long-term alignment**

---


## ğŸ“‘ Table of Contents

* âš¡ [What is Codegen Blueprint (Today)?](#-what-is-codegen-blueprint-today)
* ğŸ§ª [Executable Architecture â€” Proof](#-executable-architecture--proof)
* ğŸ§­ [1.0.0 Release Scope](#-100-release-scope)
* ğŸ§± [Architecture Overview](#-architecture-overview)
* ğŸ”Œ [Inbound & Outbound Adapters](#-inbound--outbound-adapters)
* ğŸ”„ [CLI Usage (Spring Boot)](#-cli-usage-spring-boot)
* ğŸ§ª [Testing & CI (This Repository)](#-testing--ci-this-repository)
* ğŸš€ [Vision & Roadmap](#-vision--roadmap)
* â­ [Support](#-support)
* ğŸ›¡ [License](#-license)

---

## âš¡ What is Codegen Blueprint (Today)?

A **CLI-driven**, **profile-based**, **architecture-aware** project generator
that turns architectural decisions into **executable output**.

ğŸ“Œ Current profile: **spring-boot-maven-java**

> Spring Boot 3.5+ Â· Java 21 Â· Maven â€” production-ready baseline

Codegen Blueprint today delivers:

* Deterministic, production-ready project scaffolding
* Clean source layout (main and test) with verified bootstrapping
* **Framework-free domain core by construction**
* Profile-driven architecture selection (standard / hexagonal)
* Optional architecture guardrails via generated ArchUnit tests  
  *(enabled with `--guardrails basic | strict`)*
* Maven configuration, wrapper, and build baseline
* Application configuration (`application.yml`)
* Optional **basic sample code** for both:
  * **standard (layered)** layout
  * **hexagonal (ports & adapters)** layout

> Architecture is not only generated â€”  
> it can be **evaluated and verified at build time as part of the project output**.

---

### ğŸ§ª Executable Architecture â€” Proof

Codegen Blueprint turns architectural intent into **generated, executable rules**
that are evaluated during the build.

With **strict guardrails** enabled:
* architectural boundaries are translated into ArchUnit rules
* violations fail `mvn verify` deterministically
* drift surfaces early, while context is still fresh

ğŸ‘‰ See the full, reproducible walkthrough:  

[Executable Architecture Proof](docs/demo/executable-architecture-proof.md)

---

## ğŸ§± Architecture Overview

Architecture isnâ€™t only drawn â€” it **executes** here.

Hexagonal Architecture is not a stylistic preference in Codegen Blueprint.  
It provides the **strongest architectural contract**, designed to keep architectural intent intact as systems evolve.

> Generate once.  
> Evolve across frameworks, runtimes, and languages â€” **without rewriting the core**.

**Standard (layered) architecture is supported as a first-class option**, with guardrails
**intentionally tailored to layered systems**, while Hexagonal offers stricter guarantees
through ports-and-adapters boundaries.

Both layouts are first-class and intentional â€” they differ not in importance,
but in **the strength and scope of the architectural contract they enforce**.

Spring Boot is the first delivery adapter â€” not the foundation.

ğŸ“Œ If you want to explore the architecture more deeply, these documents provide
**progressively stronger levels of clarity, guarantees, and collaboration context**:

---

- ğŸ“œ **Architecture Guardrails Rulebook**  
  A complete reference of the **architecture guardrails the engine is capable of generating**,  
  describing *the full rule surface*, *how boundaries are interpreted*,  
  and *which rule families exist across layouts and modes*.  
  *(Engine capability reference â€” **not** a 1.0.0 GA guarantee)*  

  â†’ [Architecture Guardrails Rulebook](docs/architecture/architecture-guardrails-rulebook.md)

---

- ğŸ”’ **Executable Architecture Contract â€” 1.0.0 GA**  
  The **authoritative contract** defining **exactly what Codegen Blueprint guarantees â€” and only guarantees â€”**  
  at generation and build time in the **1.0.0 GA release**.  
  *(If something is not explicitly listed in this document, it is intentionally **not guaranteed** in GA)*  

  â†’ [Executable Architecture Contract â€” 1.0.0 GA](docs/architecture/executable-architecture-contract.md)

---

- ğŸ§­ **How to Explore This Codebase (Hexagonal Guide)**  
  A practical guide to understanding ports, adapters, boundaries,  
  and how profile-driven execution shapes the system.

  â†’ [Hexagonal Architecture Guide](docs/guides/how-to-explore-hexagonal-architecture.md)

---

- ğŸ§  **Architecture Governance & AI Collaboration Protocol**  
  Describes how architectural decisions are **made visible**, **reviewed**,  
  and **kept consistent** in AI-assisted and multi-contributor environments.  

  â†’ [Architecture Governance & AI Protocol](docs/architecture/architecture-governance-and-ai-protocol.md)

---

### ğŸ§© Part of the Blueprint Platform

`codegen-blueprint` is the first foundational module of the **Blueprint Platform** â€” an architecture-first project generation ecosystem designed to enable consistent, observable, and scalable enterprise development.

Unlike traditional generators that simply scaffold code, Blueprint Platform focuses on **making architectural intent explicit and testable**, from the moment a project is generated.

It aims to:

* **Standardize enterprise best practices** through opinionated architecture and code structure
* **Integrate reusable common libraries** that encapsulate cross-cutting concerns (security, logging, error handling, tracing, OpenAPI clients, etc.)
* **Make architectural boundaries visible and verifiable** through generated structure and optional guardrails  
  (e.g. hexagonal boundaries, naming consistency, test-ready layouts)

As the platform evolves, additional modules will complement `codegen-blueprint` with:

* Ready-to-use, behavior-driven shared libraries
* Consistent and generics-aware OpenAPI client generation
* Support for multiple frameworks and technology stacks

ğŸ”— Learn more at the [Blueprint Platform GitHub organization](https://github.com/blueprint-platform)

> This aligns with the upcoming **Vision & Roadmap** section below.

> **The domain stays clean â€” ports define intent, adapters handle the outside world.**

```
domain       // business logic only
application  // orchestrates ports
adapter     // inbound/outbound driven by use cases
bootstrap   // Spring wiring + config
```

<p align="center">
  <img src="docs/images/architecture/architecture-overview.png"
       width="860"
       alt="High-level flow of Codegen Blueprint from CLI through use case, domain, artifact generation, and Spring Boot project output"/>
</p>

### Guarantees

* **No Spring annotations inside the domain**
* **Hexagonal from day zero â€” when optedâ€‘in**
* Flexible to evolve with future profiles (CQRS, Layeredâ€¦)

---

## ğŸ§­ 1.0.0 Release Scope

> ğŸ“Œ `main` branch reflects the upcoming **1.0.0 GA**.

### Included â€” GA Guarantees (1.0.0)

| Guarantee                                   | Description |
| ------------------------------------------- | ----------- |
| Deterministic project generation            | Same input always produces the same structure |
| CLI-driven generation                       | No hidden defaults, no UI-only behavior |
| Optional Hexagonal Architecture             | Ports & adapters layout generated on demand |
| Optional architecture guardrails           | Executable ArchUnit rules (basic / strict) |
| Test-ready output                           | Generated projects pass `mvn verify` |
| Profile-driven stack selection              | Technology choices defined by profiles |
| Framework-free domain core                  | No Spring dependencies in the domain |

> The 1.0.0 GA profile targets Spring Boot (3.4, 3.5), Java 21, and Maven.
> The engine is stack-agnostic by design; newer LTS versions (e.g., Java 25) may work
> but are not part of the GA compatibility contract.

---

## ğŸ”Œ Inbound & Outbound Adapters

Adapters drive interactions **in** and **out** of the core domain â€” keeping domain logic isolated, explicit, and testable.

### Inbound (Delivery) â€” How requests enter

| Adapter | Status     | Description                                          |
| ------ | ---------- | ---------------------------------------------------- |
| CLI    | âœ” GA Ready | Primary driver to generate services via command-line |
| REST   | ğŸš§ Planned | Future interactive generation + onboarding UX        |

### Outbound (Artifacts) â€” What the engine produces

> Architectural **guardrail artifacts** are generated as part of the output â€” not hard-wired into the engine.

Everything required to **build â†’ run â†’ extend** a real service:

* Maven POM + Wrapper
* Main & Test source structure
* Domain + Application + Adapter layout
* Application configuration (YAML)
* Optional **basic sample code**, depending on selected layout:
  * **standard (layered)** sample slice
  * **hexagonal (ports & adapters)** sample slice
* Optional **architecture checks (ArchUnit tests)**  
  *(enabled via `--guardrails basic|strict`)*
* README + project documentation
* Filesystem writer for artifact creation

> The domain depends on nothing â€” adapters depend on the domain.

---


## ğŸ”„ CLI Usage (Spring Boot)

This section describes the **current, accurate CLI contract** for Codegen Blueprint **1.0.0**.
It reflects the *actual generated output* and avoids aspirational or misleading examples.

---

### Basic Usage

```bash
java -jar codegen-blueprint-1.0.0.jar \
  --cli springboot \
  --group-id io.github.blueprintplatform \
  --artifact-id greeting \
  --name "Greeting" \
  --description "Greeting sample built with hexagonal architecture" \
  --package-name io.github.blueprintplatform.greeting \
  --layout hexagonal \
  --guardrails strict \
  --sample-code basic \
  --dependency web \
  --target-dir /path/to/output
```

---

### Available Options (`springboot`)

| Option            | Required | Default    | Description                                               |
|-------------------| -------- |------------|-----------------------------------------------------------|
| `--group-id`      | âœ”        | â€“          | Maven `groupId`                                           |
| `--artifact-id`   | âœ”        | â€“          | Maven `artifactId` (also becomes the project folder name) |
| `--name`          | âœ”        | â€“          | Human-readable project name                               |
| `--description`   | âœ”        | â€“          | Project description (minimum 10 characters)               |
| `--package-name`  | âœ”        | â€“          | Base Java package name                                    |
| `--build-tool`    | âœ–        | `maven`    | Build tool (currently only `maven`)                       |
| `--language`      | âœ–        | `java`     | Programming language (currently only `java`)              |
| `--java`          | âœ–        | `21`       | Java version (21, 25) â€” GA target: 21                     |
| `--boot`          | âœ–        | `3.5`      | Spring Boot version (3.4, 3.5) â€” GA target: 3.5           |
| `--layout`        | âœ–        | `standard` | `standard` (layered) or `hexagonal` (ports & adapters)    |
| `--guardrails`    | âœ–        | `basic`    | Architecture guardrails: `none`, `basic`, `strict`       |
| `--sample-code`   | âœ–        | `none`     | Sample code level: `none`, `basic`                        |
| `--dependency`    | âœ–        | â€“          | Dependency alias (repeatable, controlled set)             |
| `--target-dir`    | âœ–        | `.`        | Target directory for generated output                     |

---

### Dependency Aliases (Controlled)

> Available dependency aliases are **intentionally limited** and mapped internally
> to well-known Spring Boot starters.
>
> This avoids uncontrolled dependency sprawl and keeps generated projects aligned
> with the **architecture-first** philosophy of Codegen Blueprint.

**Available aliases in 1.0.0:**

```
web
data_jpa
validation
actuator
security
devtools
```

Invalid or unknown aliases will fail fast during CLI execution.

> `--dependency` is **repeatable**. Multiple aliases may be specified:
>
> ```bash
> --dependency web --dependency actuator --dependency data_jpa
> ```

---

### Why This Matters

Codegen Blueprint is **not** a free-form dependency injector.

Dependencies are:

* explicitly modeled
* version-aligned with the selected platform
* constrained by design

This ensures generated projects start with:

* a clean dependency graph
* predictable behavior
* architecture-safe defaults

> Dependency freedom is a runtime concern â€”
> **architectural intent is a generation-time concern.**

---

### Generated Output (Simplified)

> The output directory name **always equals `--artifact-id`**.

```
greeting/
 â”œâ”€â”€ pom.xml
 â”œâ”€â”€ .gitignore
 â”œâ”€â”€ .mvn/
 â”‚   â””â”€â”€ wrapper/
 â”‚       â””â”€â”€ maven-wrapper.properties
 â”œâ”€â”€ src/
 â”‚   â”œâ”€â”€ main/
 â”‚   â”‚   â”œâ”€â”€ java/io/github/blueprintplatform/greeting/...
 â”‚   â”‚   â””â”€â”€ resources/application.yml
 â”‚   â””â”€â”€ test/
 â”‚       â””â”€â”€ java/io/github/blueprintplatform/greeting/...
```

This output is:

* buildable (`mvn verify`)
* testable (unit + integration baseline)
* architectureâ€‘aware by construction

---

### Layout Semantics

**`standard` layout**

```
controller/
service/
repository/
domain/
config/
```

**`hexagonal` layout**

```
domain/
application/
adapter/
bootstrap/
```

No Spring annotations are placed inside the domain when hexagonal layout is selected.

---

### Architecture Guardrails & Feedback Loop

Architecture guardrails in Codegen Blueprint are **opt-in** and designed to create
a **fast, explicit feedback loop** during development â€” while context is still fresh.

They do not replace design decisions or reviews;
they make architectural boundaries **visible, testable, and hard to miss**.

#### Guardrails Modes (Adoption vs Proof)

| Mode     | Intent & Behavior                                                                                                        |
| -------- | ------------------------------------------------------------------------------------------------------------------------ |
| `basic`  | **Default (1.0.0 GA)**. Designed for **adoption**. Enforces core structural boundaries without being overly restrictive. |
| `strict` | **Recommended** for **proof-grade, fail-fast validation**. Enforces stricter dependency, layering, and boundary rules.   |
| `none`   | **Opt-out only**. Disables guardrails entirely. Intended for special cases; **not recommended** for regular use.         |

> **Default vs Recommended**
>
> * Default guardrails mode is **`basic`** to lower adoption friction.
> * **`strict`** is recommended when architectural boundaries must be enforced as a **hard, build-time contract**.
> * Selecting `none` is an explicit opt-out and should be a conscious exception.

When enabled, guardrails are generated as **executable ArchUnit tests**
and evaluated automatically during:

```bash
mvn verify
```

Violations fail the build **deterministically**, without starting the application
and without relying on runtime checks.

---

### Important Notes

* Codegen Blueprint does **not** generate cross-cutting behavior (security, logging, observability, etc.)
* Those concerns are intended to be **delivered and governed via shared libraries** in later Blueprint Platform phases
* Generated projects are intentionally minimal, stable, and architecture-first by design

> Codegen Blueprint optimizes for **long-term architectural integrity**,  
> not short-term scaffolding volume or feature breadth.

---

This section documents **what Codegen Blueprint produces today** â€”  
no demos, no aspirational features, no placeholders.

---

## ğŸ§ª Testing & CI (This Repository)

The following describes the **CI pipeline of the Codegen Blueprint repository itself** â€”
**not** the projects generated by the CLI.

It validates both:

* the **generator engine** (domain, application, adapter)
* the **real output** produced by the generator (standard & hexagonal)

---

### Local Verification

```bash
mvn verify
```

This runs the full build lifecycle, including unit tests, integration tests, and architecture rules
for the **generator itself**.

---

### CI Pipeline â€” Build & Test

The GitHub Actions workflow executes a **selective JDK matrix** designed to balance:

* **contract-level confidence** (exhaustive checks on the GA target JDK)
* **forward compatibility** (early smoke detection on the next JDK)

Rather than duplicating all checks across all JDKs, the pipeline is intentionally **asymmetric**.

---

### JDK Strategy (Intentional)

| JDK         | Purpose                         | Scope                             |
| ----------- | ------------------------------- | --------------------------------- |
| **Java 21** | **GA contract validation**      | Full verification matrix          |
| **Java 25** | **Forward-compatibility smoke** | Single generated-project scenario |

This reflects the core principle:

> **Architectural guarantees are validated exhaustively on the GA baseline,**
> while newer JDKs are used only to detect early breakage â€” not to multiply CI cost.

---

### What the CI Pipeline Verifies

#### Generator â€” Java 21 (GA Baseline)

On **Java 21 only**, the pipeline validates the generator itself:

* âœ” Unit tests
* âœ” Integration tests
* âœ” Internal architectural rules (ArchUnit)
* âœ” Coverage aggregation (JaCoCo)
* âœ” Coverage upload (Codecov)

This defines the **authoritative GA contract** for the Codegen Blueprint engine.

> The generator codebase is **not** validated against Java 25.
> Java 21 is the sole supported and guaranteed runtime for the generator itself.

---

#### Generated Projects â€” Java 21 (Full Contract Matrix)

On **Java 21**, the CI generates and verifies **six real projects**:

* âœ” **hexagonal + guardrails basic + sample basic**
* âœ” **standard  + guardrails basic + sample basic**
* âœ” **hexagonal + guardrails strict + sample basic**
* âœ” **standard  + guardrails strict + sample basic**
* âœ” **hexagonal + guardrails strict + no sample** *(canary)*
* âœ” **standard  + guardrails strict + no sample** *(canary)*

These combinations validate:

* layout differences (hexagonal vs standard)
* guardrails strength (basic vs strict)
* sample presence vs absence

Together, they define the **1.0.0 GA architectural contract surface**.

---

#### Generated Projects â€” Java 25 (Forward-Compatibility Smoke)

On **Java 25**, the CI runs **exactly one** generated-project verification:

* âœ” **hexagonal + guardrails strict + sample basic**

This scenario is intentionally chosen because it:

* exercises the **strictest guardrails**
* includes **real generated application code**
* represents the **highest architectural sensitivity**

If this passes, confidence is high that:

* the generator output remains compatible with the next JDK
* no immediate forward-compatibility breakage has been introduced

> Java 25 is **not** a supported runtime for the generator itself.
> It is used strictly as a **forward-compatibility signal** for generated output.

---

### CI Execution Flow (Simplified)

```text
Checkout repository
â†’ Java 21:
     Build & test generator (mvn clean verify)
     Generate & verify 6 projects
       - hex  + basic  + sample
       - std  + basic  + sample
       - hex  + strict + sample
       - std  + strict + sample
       - hex  + strict + no-sample  (canary)
       - std  + strict + no-sample  (canary)
     Upload coverage reports
â†’ Java 25:
     Build generator JAR (tests skipped)
     Generate & verify 1 project
       - hex + strict + sample (forward smoke)
```

---

### Coverage & Static Analysis

The pipeline includes:

* **JaCoCo** â€” unit + integration test coverage *(Java 21 only)*
* **CodeQL** â€” static security analysis
* **Codecov** â€” aggregated coverage reporting *(Java 21 only)*

> Coverage reflects **the generator engine**.
> Generated projects are validated via **successful build and guardrails execution**,
> not via coverage metrics.

---

### Why This Matters

This CI setup explicitly prevents the class of failures where:

> *â€œThe generator build is green, but the generated project is broken.â€*

By validating **real generated projects** across:

* architectural layouts
* guardrails modes
* sample presence
* GA and next-generation JDKs

Codegen Blueprint treats architecture as a **continuously verified contract** â€”
not a one-time scaffolding decision.

> **If the architecture drifts, the build tells you immediately.**

---

## ğŸš€ Vision & Roadmap

> Architecture should **execute**, not merely be drawn.  
> And it should remain observable and verifiable â€” even 6, 12, 24 months later.

### ğŸŒŸ The Vision

**Blueprint Platform** =  
ğŸ”¹ Architecture-as-a-Product  
ğŸ”¹ Capabilities delivered via libraries and governance  
ğŸ”¹ Consistency that survives time and team changes

From Day Zero to Production â€” architecture remains **intentional**, **testable**, and **continuously evaluated**.

---

### ğŸ§­ Roadmap Principles (Order Matters)

Blueprint evolves in intentional layers â€” to protect its core promise and avoid premature surface expansion.

Each phase builds on proven contracts and executable proof, not assumptions.

1. **Strengthen the contract & proof**  
   (determinism, architecture guardrails, reproducible demos)
2. **Add new delivery surfaces**  
   (CLI today â†’ REST tomorrow) **without changing the core engine**
3. **Introduce capabilities via libraries + governance**  
   (standardize behavior, donâ€™t copy-paste it)
4. **Expand profiles cautiously**  
   (Gradle/Kotlin/etc. increase surface area â€” scheduled after proof maturity)

> ğŸ“Œ Ordering matters.  
> Capabilities and profiles are introduced **only after** architectural intent is proven executable.

---

### ğŸ¯ Roadmap

#### ğŸ”¹ Phase 1 â€” Architecture-First Generation (Today)

This phase establishes the **executable architectural foundation**.

* Hexagonal / Standard (Layered) project generation (opt-in)
* Architecture guardrails via **generated ArchUnit checks**  
  (`none | basic | strict`)
* CLI-driven, profile-based generation  
  (Spring Boot Â· Maven Â· Java 21)
* Framework-free domain core by construction
* End-to-end **buildable output** evaluated in CI  
  (generated projects verified with `mvn verify`)

ğŸ“Œ **1.0.0 GA Objective** â†’ Zero-drift architectural foundations + executable proof

---

#### ğŸ”¹ Phase 2 â€” New Delivery Surface (Planned)

This phase expands **access**, not responsibility.

The core engine remains unchanged.

* REST inbound adapter  
  (same architecture engine, new entry point)
* Interactive onboarding / configuration UX  
  (still contract-first)
* Safer defaults and clearer intent capture  
  (without widening the domain surface)

ğŸ“Œ Goal â†’ expand accessibility **without rewriting the core**

---

#### ğŸ”¹ Phase 3 â€” Capability-Driven Architecture (Planned)

This phase operates at the **Blueprint Platform level**,  
not inside the generator itself.

Cross-cutting concerns are **not generated as boilerplate code**.  
They are delivered as **versioned capabilities**, governed and upgraded consistently across services.

`codegen-blueprint` acts as the **entry point and wiring engine**, enabling teams to **adopt, configure, and govern** these capabilities â€” not to implement them.

Planned capability areas include:

* ğŸ” Security capability  
  (OAuth2 / Keycloak)
* ğŸ” Observability capability  
  (tracing, logs, metrics)
* ğŸ“¡ Resilience capability  
  (retries, timeouts, policies)
* ğŸ›ï¸ Architecture policy packs  
  (versioned guardrails rulesets applied consistently across services)
* ğŸ§© Optional enterprise service kits  
  (API / Domain / Infra)
* ğŸ” Generics-aware OpenAPI clients  
  (separate Blueprint module)

ğŸ“Œ Goal â†’ consistent behavior, architectural boundaries, and upgrades  
**in one place â€” not duplicated across services**

---

#### ğŸ”¹ Phase 4 â€” Profile Expansion (Roadmap)

Profiles accelerate adoption but **increase surface area**  
(templates, tests, compatibility, support).

They are introduced only after architectural contracts and governance mature.

* Gradle support (profile)
* Kotlin support  
  (higher surface area than Gradle)
* Quarkus and future stack profiles
* Visual UI â€” configure â†’ generate â†’ download
* Governance at scale  
  (drift detection & remediation ideas)
* Platform telemetry for architecture health (opt-in)

ğŸ“Œ Goal â†’ expand stacks **after** proof and contracts are stable

---

ğŸ“Œ Community-driven priorities:  

ğŸ”— Participate via [GitHub Discussions](https://github.com/blueprint-platform/codegen-blueprint/discussions)

---

### ğŸ§© Why this matters

| Without Blueprint | With Blueprint |
|------------------|----------------|
| Architecture drifts silently | Guardrails make drift visible |
| Boilerplate everywhere | Capabilities delivered via libraries |
| Onboarding takes weeks | Day-zero structure + contracts |
| Standards depend on discipline | Standards made observable by construction |

> ğŸ“Œ The platform grows â†’ Projects stay clean â†’ Enterprise stays consistent

---

**Blueprint Platform isnâ€™t just code generation â€”  
it is strategic architectural continuity.**

---

## ğŸ¤ Contributing

We welcome:

* Architecture improvements
* Stack profiles & adapters
* Template & documentation enhancements

Start here â†’

- ğŸ”— [GitHub Discussions](https://github.com/blueprint-platform/codegen-blueprint/discussions)

- ğŸ”— [GitHub Issues](https://github.com/blueprint-platform/codegen-blueprint/issues)

---

## â­ Support

If this project saves your team time or headaches,
**please consider starring the repository** â€” it genuinely helps with visibility and longâ€‘term sustainability.

---

**BarÄ±ÅŸ SaylÄ±**  
Creator & Maintainer

* GitHub: [https://github.com/bsayli](https://github.com/bsayli)

* LinkedIn: [https://www.linkedin.com/in/bsayli](https://www.linkedin.com/in/bsayli)

* Medium: [https://medium.com/@baris.sayli](https://medium.com/@baris.sayli)

---

## ğŸ›¡ License

MIT â€” free for commercial and personal use.

See: [LICENSE](LICENSE)
