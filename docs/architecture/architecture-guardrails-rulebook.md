# Architecture Guardrails Rulebook

**Build-time architectural guardrails generated and evaluated by Codegen Blueprint.**

This document defines the **authoritative architecture guardrails contract** that Codegen Blueprint is capable of generating and enforcing at build time.

> âš ï¸ **Important**
>
> This document describes the **guardrails system and contract**.
> It does **not** imply that all guardrails are enabled in every generated project.
> **Release-level guarantees** and defaults are declared explicitly by the CLI and release notes.

---

## ðŸ“‘ Table of Contents

- [Intent and positioning](#intent-and-positioning)
- [Guardrails overview](#guardrails-overview)
  - [Mechanism](#mechanism)
  - [Structural assumption (critical)](#structural-assumption-critical)
  - [Failure behavior](#failure-behavior)
- [Guardrails modes](#guardrails-modes)
  - [none](#none)
  - [basic](#basic)
  - [strict](#strict)
- [Guardrails categories](#guardrails-categories)
- [Schema & contract guardrails (core concept)](#schema--contract-guardrails-core-concept)
  - [What schema guardrails enforce](#what-schema-guardrails-enforce)
  - [What schema guardrails do NOT do](#what-schema-guardrails-do-not-do)
- [Hexagonal architecture guardrails](#hexagonal-architecture-guardrails)
  - [Hexagonal â€” Basic](#hexagonal--basic)
  - [Hexagonal â€” Strict](#hexagonal--strict)
- [Standard (Layered) architecture guardrails](#standard-layered-architecture-guardrails)
  - [Standard â€” Basic](#standard--basic)
  - [Standard â€” Strict](#standard--strict)
- [What guardrails do NOT cover](#what-guardrails-do-not-cover)
- [Generated test locations](#generated-test-locations)
- [Versioning guarantee](#versioning-guarantee)
- [Summary](#summary)

---

## Intent and positioning

Codegen Blueprint does **not** document or recommend architecture styles.

Instead, it:

* **Generates architecture as an executable contract**
* **Compiles architectural intent into deterministic build-time checks**
* **Fails fast when the contract is violated**

Architecture here is **not guidance**.
It is **enforced structure**.

---

## Guardrails overview

### Mechanism

* Guardrails are implemented as **generated ArchUnit tests**
* Tests are generated based on:

  * Selected **layout** (`hexagonal` or `standard`)
  * Selected **guardrails mode** (`none`, `basic`, `strict`)
* Rules are evaluated automatically during:

```bash
mvn verify
```

No application startup is required.
No runtime behavior is involved.

---

### Structural assumption (critical)

Guardrails are evaluated against a **deterministic package schema** generated by Codegen Blueprint.

The generated source layout is **not cosmetic**.
It is the **structural foundation** of the architecture contract.

Renaming or relocating canonical package families **changes the contract** and is therefore detected explicitly.

---

### Failure behavior

* Any guardrails violation causes the build to **fail immediately**
* Failures are:

  * Deterministic
  * Build-time only
  * Independent of runtime execution

There are **no soft warnings** and **no silent bypasses**.

---

## Guardrails modes

### none

* No architecture tests are generated
* No guardrails guarantees are provided

---

### basic

**Adoption-friendly structural guardrails.**

Basic mode focuses on:

* Preventing **obvious architectural violations**
* Preserving **minimal structural sanity**
* Avoiding over-constraint during early adoption

Basic mode enforces:

* Core dependency direction rules
* Bounded-context **schema completeness**
* Early detection of structural drift

It intentionally avoids strict schema policing.

---

### strict

**Contract-first architectural enforcement.**

Strict mode treats architecture as **non-negotiable**:

* Dependency direction is fully enforced
* Public boundaries are isolated
* Canonical package families are enforced
* Rename-based guardrails bypass is prevented

Strict mode is intended for teams that treat architecture as a **product contract**, not a convention.

---

## Guardrails categories

Guardrails fall into **three distinct categories**:

1. **Dependency guardrails**
2. **Boundary guardrails**
3. **Schema & contract guardrails**

Understanding this distinction is essential.

---

## Schema & contract guardrails (core concept)

Schema guardrails ensure that the **structural contract itself** remains intact.

They prevent guardrails from being silently disabled through refactoring.

### What schema guardrails enforce

* Canonical package family names are **part of the contract**
* Bounded contexts are detected deterministically via package heuristics
* Required package families must exist per detected context
* Unknown or renamed families inside a context are rejected (strict mode)
* Empty guardrails scope fails fast (no false-green builds)

### What schema guardrails do NOT do

* They do not enforce dependency direction
* They do not prescribe internal design
* They do not police code outside detected contexts

Schema guardrails exist to ensure that **dependency rules continue to mean what they claim to mean**.

---

## Hexagonal architecture guardrails

### Hexagonal â€” Basic

**Guaranteed rules**

* Application layer must **not depend on adapters**
* Bootstrap layer is a **leaf** (no other package may depend on it)
* Inbound adapters must not depend on outbound adapters
* Outbound adapters must not depend on inbound adapters
* No cyclic dependencies between top-level packages
* Each detected hexagonal bounded context must contain:

  * `application`
  * `adapter`
  * `domain`

**Intent**

Hexagonal Basic:

* Protects core use cases from infrastructure concerns
* Prevents adapter-to-adapter coupling
* Preserves replaceable bootstrapping
* Detects early structural drift without enforcing strict schema policing

---

### Hexagonal â€” Strict

Hexagonal Strict enforces **full architectural contract integrity**.

#### Adapter direction isolation

* Inbound adapters must not depend on outbound adapters
* Outbound adapters must not depend on inbound adapters

---

#### Domain purity

* Domain may depend **only on**:

  * JDK types (`java.*`)
  * Other domain types

No framework, adapter, or application dependencies are allowed.

---

#### Inbound adapter isolation

* Inbound adapters must not depend on:

  * Domain services
  * Domain outbound ports

---

#### Application implementation isolation

* Adapters must not depend on application implementation classes
* Only application ports are allowed as adapter dependencies

---

#### Schema & rename enforcement

* Within each detected bounded context:

  * The **first package segment** under the context root must be one of:

    * `adapter`
    * `application`
    * `domain`
    * `bootstrap`

This prevents rename-based guardrails bypass.

---

#### Package cycle prevention

* No cyclic dependencies between top-level packages
* No cycles inside adapter subpackages

---

#### REST boundary isolation (Spring Web only)

Enforced only when `spring-boot-starter-web` is present.

* REST controllers must not expose domain types in:

  * Return types
  * Parameters
  * Generic signatures
* Inbound adapter DTOs must not depend on domain

---

## Standard (Layered) architecture guardrails

### Standard â€” Basic

**Guaranteed rules**

* Controllers must not depend on repositories
* Domain must not depend on:

  * Controllers
  * Services
  * Repositories
* No cyclic dependencies between top-level packages
* For each detected bounded context:

  * If `controller` exists, `service` and `domain` must also exist

**Intent**

Standard Basic:

* Prevents service-layer bypass
* Preserves delivery / orchestration / domain separation
* Avoids over-constraining persistence choices
* Provides safe baseline guardrails for layered architecture

---

### Standard â€” Strict

Standard Strict enforces a **fully explicit layered contract**.

#### Layer dependency enforcement

* Controllers must not depend on repositories
* Controllers must not depend on domain services
* Services must not depend on controllers
* Repositories must not depend on services or controllers

---

#### Domain purity

* Domain may depend only on:

  * JDK types
  * Other domain types

---

#### Schema & rename enforcement

* Within each detected bounded context, every class must reside under one of:

  * `controller`
  * `service`
  * `repository`
  * `domain`
  * `config`

This prevents silent bypass via package renaming.

---

#### Package cycle prevention

* No cyclic dependencies inside:

  * controller
  * service
  * repository
  * domain
  * config

---

#### REST boundary isolation (Spring Web only)

* REST controllers must not expose domain types in:

  * Return types
  * Parameters
  * Generic signatures
* Controller DTOs must not depend on domain

---

## What guardrails do NOT cover

Guardrails are **structural**, not behavioral.

Explicitly out of scope:

* Code style or formatting
* Naming aesthetics (beyond contract enforcement)
* Business rule correctness
* Runtime behavior (transactions, security, performance)
* Dependency vulnerability scanning

---

## Generated test locations

Architecture guardrails are generated under:

```
src/test/java/<projectPackage>/architecture/archunit/**
```

They are:

* Deterministic
* Generated from templates
* Versioned as part of the GA contract

---

## Versioning guarantee

This guardrails rulebook is part of the **1.0.0 GA architecture contract**.

* Changes to these rules are treated as **contract changes**
* Contract changes require explicit version upgrades
* No silent guardrails changes occur within a GA line

---

## Summary

Codegen Blueprint treats architecture as **an executable product**:

* Architectural intent is generated, not implied
* Structural boundaries are compiled into build-time feedback
* Drift is surfaced immediately through deterministic failures

> When a guardrail is violated, the build does not warn.
> **It fails â€” clearly, early, and on purpose.**
