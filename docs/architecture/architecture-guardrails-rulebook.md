# Architecture Guardrails Rulebook

**Build-time architectural guardrails generated and evaluated by Codegen Blueprint.**

This document defines the **authoritative guardrails contract vocabulary and rule semantics**
that Codegen Blueprint is capable of generating and evaluating at build time.

> ‚ö†Ô∏è **Important**
>
> This document describes the **guardrails system and its architectural contract**.
> It does **not** imply that all guardrails are enabled in every generated project.
> **Release-level guarantees, defaults, and opt-in behavior** are declared explicitly by the CLI and release notes.

---

## üìë Table of Contents

* [Intent and positioning](#intent-and-positioning)
* [Guardrails overview](#guardrails-overview)
  * [Mechanism](#mechanism)
  * [Structural assumption (critical)](#structural-assumption-critical)
  * [Failure behavior](#failure-behavior)
* [Guardrails modes](#guardrails-modes)
  * [none](#none)
  * [basic](#basic)
  * [strict](#strict)
* [Guardrails categories](#guardrails-categories)
* [Schema & contract guardrails (core concept)](#schema--contract-guardrails-core-concept)
  * [What schema guardrails enforce](#what-schema-guardrails-enforce)
  * [What schema guardrails do NOT do](#what-schema-guardrails-do-not-do)
* [Hexagonal architecture guardrails](#hexagonal-architecture-guardrails)
  * [Hexagonal ‚Äî Basic](#hexagonal--basic)
  * [Hexagonal ‚Äî Strict](#hexagonal--strict)
* [Standard (Layered) architecture guardrails](#standard-layered-architecture-guardrails)
  * [Standard ‚Äî Basic](#standard--basic)
  * [Standard ‚Äî Strict](#standard--strict)
* [What guardrails do NOT cover](#what-guardrails-do-not-cover)
* [Generated test locations](#generated-test-locations)
* [Versioning guarantee](#versioning-guarantee)
* [Appendix A ‚Äî Architecture Contract Vocabulary](#appendix-a--architecture-contract-vocabulary)
* [Summary](#summary)

---

## Intent and positioning

Codegen Blueprint does **not** document, teach, or recommend architecture styles.

Instead, it:

* **Generates architecture as an executable contract**
* **Compiles architectural intent into deterministic build-time checks**
* **Fails fast when the contract is violated**

Architecture here is **not guidance**.
It is **enforced structure**.

---

## Guardrails overview

### Mechanism

* Guardrails are implemented as **generated ArchUnit tests**
* Tests are generated based on:

  * Selected **layout** (`hexagonal` or `standard`)
  * Selected **guardrails mode** (`none`, `basic`, `strict`)
* Rules are evaluated automatically during:

```bash
mvn verify
```

No application startup is required.
No runtime behavior is involved.

---

### Structural assumption (critical)

Guardrails are evaluated against a **deterministic package schema** generated by Codegen Blueprint.

The generated source layout is **not cosmetic**.
It is the **structural foundation of the architecture contract**.

Renaming, removing, or relocating canonical package families **changes the contract** and is therefore surfaced explicitly by guardrails.

---

### Failure behavior

* Any guardrails violation causes the build to **fail immediately**
* Failures are:

  * Deterministic
  * Build-time only
  * Independent of runtime execution

There are **no soft warnings** and **no silent bypasses**.

---

## Guardrails modes

### none

* No architecture tests are generated
* No guardrails guarantees are provided

---

### basic

**Adoption-friendly structural guardrails.**

Basic mode focuses on:

* Preventing **obvious architectural violations**
* Preserving **minimal structural sanity**
* Detecting early **structural drift**

Basic mode enforces:

* Core dependency direction rules
* Bounded-context **schema completeness**
* Guardrails scope sanity (no false-green builds)

It intentionally avoids **strict contract/vocabulary policing** (e.g., rename-escape / near-miss detection)
and does not attempt full **contract integrity** enforcement beyond minimal schema integrity checks.

---

### strict

**Contract-first architectural enforcement.**

Strict mode treats architecture as **non-negotiable**:

* Dependency direction is fully enforced
* Public and framework boundaries are isolated
* Canonical package vocabulary is treated as contractual reference

Strict mode is intended for teams that treat architecture as a **product contract**, not a convention.

---

## Guardrails categories

Guardrails fall into **three distinct categories**:

1. **Dependency guardrails** ‚Äî control allowed dependency directions
2. **Boundary guardrails** ‚Äî protect public and framework-facing boundaries
3. **Schema & contract guardrails** ‚Äî protect the *meaning* and *scope* of the architecture itself

Understanding this distinction is essential to reading guardrails correctly.

---

## Schema & contract guardrails (core concept)

Schema guardrails ensure that the **structural contract itself remains intact**.

They exist to prevent guardrails from being silently disabled or rendered meaningless through refactoring.

### Canonical vocabulary and generated contract surface

Canonical package vocabulary is not only described in this rulebook ‚Äî it is also **generated as code** in every project.

* The canonical vocabulary tokens used by guardrails are generated under:
  * `src/test/java/<projectPackage>/architecture/archunit/*GuardrailsScope.java`
* This rulebook defines **guardrails semantics and interpretation**.
* The generated `*GuardrailsScope` classes define the **authoritative vocabulary tokens** referenced by the generated ArchUnit tests.

If these vocabulary tokens are renamed or relocated, this is treated as a **contract change** (not a refactor) and may cause guardrails to fail by design.

### What schema guardrails enforce

* Canonical package vocabulary is part of the **architecture contract**
* Bounded contexts are detected deterministically via package heuristics
* Required package families must exist per detected bounded context
* Guardrails scope must not be empty (no silent green builds)

Schema guardrails validate **completeness and integrity**, not stylistic preference.

### What schema guardrails do NOT do

* They do not enforce dependency direction
* They do not prescribe internal design patterns
* They do not forbid all renames or alternative internal structures
* They do not police code outside detected bounded contexts

Schema guardrails ensure that **dependency and boundary rules continue to mean what they claim to mean**.

---

## Hexagonal architecture guardrails

### Hexagonal ‚Äî Basic

**Rules enforced by Hexagonal Basic mode**

When Hexagonal layout is selected and guardrails are enabled in **`basic` mode**,
the following rules are generated and evaluated at build time.

* The application layer must **not depend on adapters**.
* The bootstrap layer is treated as a **leaf**:
  non-bootstrap packages must not depend on `bootstrap`.
* For each detected bounded context root, there must be **no cyclic dependencies across first-segment slices**
  under that context root (e.g. `adapter` / `application` / `domain` / `bootstrap`).
* Each detected hexagonal bounded context must contain the canonical families:
  * `application`
  * `adapter`
  * `domain`
* Guardrails scope must **not be empty**,
  failing fast to prevent ‚Äúsilent green builds‚Äù after root package refactors.

---

**Intent**

Hexagonal Basic is designed to provide **early, adoption-friendly structural protection**:

* It protects core use cases from infrastructure concerns
  (the application layer cannot drift into adapters).
* It preserves replaceable bootstrapping by preventing `bootstrap`
  from becoming a shared dependency hub.
* It detects structural drift early via:
  * bounded-context schema completeness checks, and
  * bounded-context cycle checks,

without enforcing strict vocabulary policing or full contract rigidity.

---

### Hexagonal ‚Äî Strict

Hexagonal Strict enforces **full architectural contract integrity** across adapters, application, and domain ‚Äî and adds **local cycle prevention** plus **REST boundary isolation**.

#### Adapter direction isolation

* Inbound adapters (`adapter.in`) must not depend on outbound adapters (`adapter.out`).
* Outbound adapters (`adapter.out`) must not depend on inbound adapters (`adapter.in`).

---

#### Domain purity

* Domain may depend **only on**:
  * JDK types (`java.*`)
  * Other domain types (within the generated base package)

No framework, adapter, or application dependencies are allowed.

---

#### Inbound adapter isolation

* Inbound adapters (`adapter.in`) must not depend on:
  * Domain services (`domain.service`)
  * Domain outbound ports (`domain.port.out`)

---

#### Application implementation isolation

* Adapters must not depend on application implementation classes.
* Adapters may depend only on **application ports** under `application.port..`
  (anything under `application..` that is **not** within `application.port..` is treated as implementation).

---

#### Bootstrap leaf enforcement

* The bootstrap layer (`bootstrap`) is a **strict leaf**.
* No non-bootstrap package may depend on `bootstrap`.

**Rationale**

* `bootstrap` is the composition root and wiring layer.
* It may reference application, adapters, and domain to assemble the system.
* The rest of the system must remain completely unaware of bootstrap.

Any dependency **toward** `bootstrap` represents an architectural inversion and
violates hexagonal separation of concerns.

---

#### Package cycle prevention

* No cyclic dependencies **inside** each hexagonal family:
  * `adapter`
  * `application`
  * `domain`
  * `bootstrap`
* No cyclic dependencies **inside** adapter sub-families:
  * `adapter.in..`
  * `adapter.out..`

> Note: This is **family-local** cycle prevention (not ‚Äúbetween top-level packages‚Äù).
> Strict mode enforces cycle-freedom by family slices and adapter sub-slices.

---

#### REST boundary signature isolation (Spring Web only)

* REST controllers under `adapter.in..` annotated with `@RestController` must **not expose domain types**
  in method signatures, including:
  * Return types
  * Parameter types
  * Generic signatures (deep inspection of involved raw types)

---

#### Inbound DTO isolation

* Inbound adapter DTOs (`adapter.in..dto..`) must not depend on domain types.

---

## Standard (Layered) architecture guardrails

### Standard ‚Äî Basic

Standard Basic guardrails define a **safe, low-friction architectural baseline**
for classic layered systems.

They are designed for **early adoption** and focus on:

* **Directional dependency correctness**
* **Minimal structural integrity**
* **Early detection of obvious architectural drift**

They intentionally avoid strict vocabulary policing and framework-level isolation,
which are deferred to **Standard ‚Äî Strict**.

---

#### Rules enforced when Standard Basic guardrails are enabled

##### Controller ‚Üî Repository isolation

When guardrails are enabled in **Standard ‚Äî Basic** mode:

* Controllers (`controller`) **must not depend on** repositories (`repository`)
* Repositories (`repository`) **must not depend on** controllers (`controller`)

This enforces a minimal layered boundary and prevents:

* Bypassing the service layer
* Mixing delivery concerns with persistence logic
* Accidental tight coupling between entrypoints and data access

> This rule enforces **dependency isolation**, not call ordering.
> It ensures that delivery and persistence concerns remain structurally decoupled,
> even in early-stage or low-friction layered architectures.

---

##### Domain independence

* Domain (`domain`) must **not depend on**:
  * Controllers (`controller`)
  * Services (`service`)
  * Repositories (`repository`)

The domain remains the **innermost layer**:
* Free of delivery concerns
* Free of orchestration logic
* Free of persistence and infrastructure dependencies

This preserves the ability to reason about domain behavior independently of the rest of the system.

---

##### Bounded context cycle prevention

* No cyclic dependencies are allowed **within each detected bounded context**
  across its top-level packages.

Cycles are evaluated per bounded context root, not globally, which allows:
* Multiple bounded contexts
* Nested or sibling sub-roots
* Incremental growth without global coupling

A cyclic dependency always indicates unclear responsibility boundaries and must be resolved.

---

##### Bounded context completeness (schema sanity)

For each detected bounded context:

* If a `controller` package exists, then:
  * `service` **must** exist
  * `domain` **must** exist

Notes:
* `repository` is intentionally **optional**
* Persistence is not mandatory for every bounded context
* Read-only or orchestration-only contexts remain valid

This rule prevents **half-defined bounded contexts** that silently drift over time.

---

#### What Standard Basic intentionally does NOT enforce

* No strict controller ‚Üí service ‚Üí repository call ordering
* No framework isolation rules
* No DTO boundary enforcement
* No config/package dependency restrictions
* No REST signature inspection

These are deliberately deferred to **Standard ‚Äî Strict** to keep adoption friction low.

---

#### Intent

Standard Basic is designed to:

* Establish **clear layer separation** without over-policing
* Prevent common architectural shortcuts (service bypass, domain leakage)
* Allow flexible persistence strategies
* Support both:
  * Flat package layouts
  * Nested bounded-context sub-roots

It provides a **stable architectural floor** that teams can adopt quickly,
while still enabling stricter enforcement when the system matures.

---

> Standard Basic is not about perfection.
> It is about preventing **obvious structural mistakes** early,
> before they harden into architectural debt.

### Standard ‚Äî Strict

Standard Strict enforces a **fully explicit layered contract** for the STANDARD (layered) layout.
It goes beyond ‚Äúdon‚Äôt do obvious mistakes‚Äù and instead validates **layer purity**, **domain purity**, **cycle-freedom**
and **REST boundary integrity** (Spring Web only).

---

#### Layer dependency enforcement

Standard Strict enforces **directional isolation** between the canonical families:

* Controllers (`controller`) must **not depend on** repositories (`repository`)
* Controllers (`controller`) must **not depend on** domain services (`domain.service`)
* Services (`service`) must **not depend on** controllers (`controller`)
* Repositories (`repository`) must **not depend on** services (`service`) **or** controllers (`controller`)

Intent:

* Controllers are delivery-only (HTTP boundary), not orchestration and not persistence-aware.
* Orchestration belongs to the service layer.
* Persistence is isolated from delivery and orchestration.
* Domain services are never invoked directly from controllers (service layer is mandatory).

> Note: This is about **dependencies**, not call graphs.  
> REST signature leakage is enforced separately.

---

#### Domain purity

Domain (`domain`) is treated as a **pure core** (within the layered model).

* Domain may depend **only on**:
  * JDK types (`java.*`)
  * Other domain types (within the generated base package)

No framework, controller, service, repository, or config dependencies are allowed.

This prevents ‚Äúdomain as a dumping ground‚Äù and ensures the domain remains stable and portable.

---

#### Package cycle prevention

Standard Strict forbids cyclic dependencies **inside each canonical family**:

* `controller`
* `service`
* `repository`
* `domain`
* `config`

This is **family-local** cycle prevention:
* Cycles are detected within each family slice (`family.(*)..`)
* It does not attempt to prevent cycles *between* families (that is already handled by dependency direction rules)

Cycles always indicate unclear boundaries and must be resolved by refactoring responsibilities.

---

#### REST boundary integrity (Spring Web only)

For REST controllers (`controller..`) annotated with `@RestController`:

* REST controllers must **not expose domain types** in method signatures, including:
  * Return types (raw)
  * Parameter types (raw)
  * Generic signatures (deep inspection of all involved raw types)

Additionally:

* Controller DTOs (`controller.dto..`) must **not depend on domain types**

Intent:

* Domain types must not leak through HTTP APIs.
* Controllers remain a strict delivery boundary.
* DTOs stay boundary-local and do not ‚Äúimport the domain‚Äù by accident.

---

#### Why this matters

Standard Strict is designed for teams that want:

* Deterministic, build-time enforcement of layered boundaries
* A domain that remains framework-free and stable
* Continuous prevention of package-level erosion (cycles)
* A REST API surface that does not leak internal domain structures

It turns ‚Äúlayered architecture‚Äù from a convention into an **executable contract**.

---

## What guardrails do NOT cover

Guardrails are **structural**, not behavioral.

Explicitly out of scope:

* Code style or formatting
* Naming aesthetics (beyond contract vocabulary)
* Business rule correctness
* Runtime behavior (transactions, security, performance)
* Dependency vulnerability scanning

---

## Generated test locations

Architecture guardrails are generated under:

```
src/test/java/<projectPackage>/architecture/archunit/**
```

They are:

* Deterministic
* Generated from templates
* Versioned as part of the GA contract

---

## Versioning guarantee

This guardrails rulebook defines the **stable contract vocabulary and rule semantics**
that Codegen Blueprint is capable of generating and evaluating at build time.

It guarantees that, within a **GA release line**:

* The **meaning, scope, and intent** of documented guardrails are stable and versioned
* Any change to guardrail **semantics or interpretation** is treated as a **contract change**
* Contract changes require an **explicit version upgrade**
* No silent or implicit changes to guardrails behavior occur within the same GA line

> üìå Important clarification  
> This rulebook describes **engine-level guardrails semantics and vocabulary**.  
> It does **not** define which guardrails are guaranteed, enabled, or active by default in a given release.

---

### Activation and defaults (important)

This rulebook defines **what guardrails mean**,  
not **which guardrails are enabled in a generated project**.

Whether a project enables:

* `none`
* `basic`
* `strict`

is determined **explicitly by CLI flags and release-level defaults**,  
not by this document.

For **Codegen Blueprint 1.0.0 GA**:

* The default guardrails mode is **`basic`**
* **`strict`** guardrails are **explicitly opt-in**
* No project is forced into strict enforcement unless explicitly requested

The **authoritative source** for:

* default guardrails mode
* opt-in / opt-out behavior
* availability of guardrails per layout

is the **CLI contract and the release notes**, not this rulebook.

This separation is intentional:

* The **rulebook** defines guardrails **semantics and vocabulary**
* The **CLI and release artifacts** define **activation and guarantees**

---

## Appendix A ‚Äî Architecture Contract Vocabulary

This appendix defines the **contract language** used by guardrails.
It explains how rules should be *read*, not how code should be written.

### Canonical package family

A **canonical package family** is a vocabulary token emitted by the generator and referenced by guardrails (e.g. `application`, `adapter`, `domain`).

It is:

* A **contractual reference point**
* Not a stylistic recommendation
* Not a forced internal structure

Changing a canonical family name is a **contract change**, not a refactor.

---

### Bounded context (Blueprint definition)

A bounded context is **inferred**, not declared.

Blueprint detects bounded contexts via deterministic package heuristics (e.g. presence of `application` or `controller`).

Guardrails apply **per detected context**, not globally.

---

### Application use case vs domain service

* **Application use cases** live in the application layer

  * Orchestration
  * Transaction boundaries
  * Coordination of ports

* **Domain services** live in the domain layer

  * Pure business behavior
  * No infrastructure or framework dependencies

Renaming `usecase` to `handler` is allowed **only if the contract is updated intentionally**.

---

### Port vs implementation

* Ports define **allowed dependency directions**
* Implementations are **replaceable details**

Guardrails enforce *who may depend on which abstraction*, not how implementations are written.

---

### Contract change vs refactor

A refactor preserves the contract.
A contract change modifies what guardrails mean.

Examples of **contract changes**:

* Renaming canonical families
* Moving code outside detected bounded contexts
* Collapsing or removing required families

Contract changes are allowed ‚Äî but **must be explicit and intentional**.

---

## Summary

Codegen Blueprint treats architecture as **an executable product**:

* Architectural intent is generated, not implied
* Structural boundaries are compiled into build-time feedback
* Drift is surfaced immediately through deterministic failures

> When a guardrail is violated, the build does not warn.
> **It fails ‚Äî clearly, early, and on purpose.**
